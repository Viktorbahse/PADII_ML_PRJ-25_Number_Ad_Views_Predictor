# Попытка симуляционного решения задачи

## 1. Общая идея и архитектура решения

Для решения задачи прогнозирования охвата рекламных объявлений был выбран **симуляционный подход**. Основная идея заключается не в построении одной большой ML-модели, которая напрямую предсказывает итоговый результат, а в декомпозиции задачи на несколько независимых блоков с последующим моделированием их взаимодействия.

1.  **Модель Активности Пользователя**: Отвечает на вопрос "Сколько раз у пользователя появится возможность увидеть рекламу в заданный час?".
2.  **Модель Рекламного Аукциона**: Отвечает на вопрос "Какова вероятность нашего объявления выиграть один конкретный аукцион?".
3.  **Процесс Симуляции**: Объединяет две предыдущие модели, итерируясь по времени и по каждому пользователю из целевой аудитории, чтобы накопить итоговое количество просмотров с учетом правил системы.

Далее каждый компонент будет рассмотрен подробно.

## 2. Модель Активности Пользователя

Цель компонента — для любого пользователя `u` и часа `h` предсказать ожидаемое количество рекламных слотов (возможностей показа), которые у него появятся.

### 2.1. Постановка задачи и выбор модели

Изначально задача рассматривалась как бинарная классификация ("активен / не активен"), однако анализ данных показал, что пользователи могут видеть несколько объявлений за час. Это означает, что происходит несколько аукционов. Поэтому перешли к задаче регрессии.

В качестве модели был выбран градиентный бустинг **LightGBM Regressor**. Лучший результат показала функция потерь `objective='tweedie'`, потому что в наших данных очень много нулей и большая дисперсия, т.к. добавили много примеров отсутствия активности пользователей, часов когда не показано ни одного объявления.

### 2.2. Feature Engineering

Для обучения модели был создан набор признаков, характеризующих пользователя и временной контекст. Все пользовательские признаки были предподсчитаны и сохранены в файл `users_with_features.pkl` для быстрого доступа.

**Ключевые группы признаков:**

*   **Временные**: `hour_of_day`, `day_of_week`. Гипотеза, что это самые важные признаки, отражающие суточные и недельные циклы активности.
*   **Статические пользовательские**: `sex`, `age`, `city_id`. Признак `city_id` оказался крайне важным, что, скорее всего, связано с необходимостью учета часовых поясов.
*   **Агрегированные поведенческие**:
    *   Характеристики общей вовлеченности пользователя: `total_impressions`, `active_days`, `active_hours` и т.д.
    *   Распределение активности во времени: `impressions_h_*`, `impressions_d_*` (количество показов в каждый час дня / день недели).
    *   Активность относительно вовлеченности: `ratio_impressions_h_*` и `ratio_impressions_d_*`. Нормализованные на общую активность пользователя признаки, которые дали небольшое, но заметное улучшение качества модели.

### 2.3. Результаты
Модель активности показала хорошее качество на отложенной временной выборке (RMSE ~0.65, MAE ~0.36). Анализ важности признаков подтвердил корректность выбранных гипотез: `hour_of_day` и `city_id` влияют сильнее всего. Чуть менее заметно влияние `age` и `day_of_week`. Агрегированные признаки все получили примерно одинаковую небольшую важность.

## 3. Модель Рекламного Аукциона

Цель этого компонента — оценить вероятность `p_win` выигрыша нашего объявления со ставкой `cpm` в одном конкретном аукционе.

### 3.1. Выбранный подход
Вместо сложной ML-модели был выбран статистический подход, основанный на исторических данных о выигравших ставках из `history.tsv`. Так сохранили простоту и относительно высокую производительность.

Был создан словарь (`cpm_slot_lookup.pkl`), где для каждого "слота", определяемого ключом `(day_of_week, hour_of_day, publisher)`, хранился массив всех выигравших CPM. Вероятность выигрыша `p_win` рассчитывалась на основе доли исторических ставок, которые были меньше или равны нашей ставке `my_cpm`.

### 3.2. Упрощения и нерешенные проблемы
Для сохранения быстродействия в этой модели был принят ряд упрощений, которые, вероятно, и стали основным источником итоговой ошибки:

*   **Единая модель для всех пользователей**: Модель не учитывает, какому именно пользователю будет показана реклама. В реальности конкуренция за разных пользователей может сильно отличаться.
*   **Слоты без исторических данных**: Для них брали фиксированное значение вероятности. Экспериментально было установлено, что этот параметр сильно влияет на итоговый результат. Сильно меньшие значения, например `fallback=0.03` значительно улучшило качество по сравнению с наивным `0.5`.
*   **Не учтена ценность пользователя**: Мы не использовали информацию о том, что некоторые пользователи являются более "ценными" (исторически видят более дорогую рекламу). Учет этого фактора мог бы значительно повысить точность `p_win`, но потребовал бы усложнения симуляции и, как следствие, привел бы к потере производительности из-за отказа от векторизации.

## 4. Процесс Симуляции

Процесс симуляции объединяет обе модели для получения итоговых предсказаний. Сначала написал наивно через вложенные циклы, но работало очень медленно.

**Алгоритм симуляции для одного объявления:**

1.  Загружаются все результаты обучения и предподсчета: модель активности, таблица признаков пользователей и словарь результатов аукционов.
2.  Создаются векторные переменные состояния для всех пользователей из аудитории (`total_views_per_user`, `last_view_hour`).
3.  Запускается основной цикл только по часам рекламной кампании.
4.  Для каждого часа `h`:
    *   Для всех пользователей одновременно формируется матрица признаков.
    *   Одним вызовом `activity_model.predict()` получается вектор ожидаемых активностей `lambda_vals`.
    *   Из распределения Пуассона генерируется вектор `N_opps` (количество рекламных возможностей для каждого пользователя).
    *   Рассчитывается `p_win` для данного часа.
    *   С помощью биномиального распределения симулируется вектор `hourly_wins` (количество выигранных аукционов для каждого пользователя).
    *   Векторно применяется правило 6-часовой сессии: выигрыши не засчитываются для тех, кто уже видел наше объявление в течение сессии.
    *   Векторно обновляются итоговые счетчики `total_views_per_user` и `last_view_hour` для победителей.
5.  После завершения цикла по часам, по итоговому вектору `total_views_per_user` рассчитываются финальные доли `at_least_one/two/three`.

Так избежали медленных вложенных циклов python.

